"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrap = exports.createContextHelper = exports.createHelpers = exports.createHelper = void 0;
var jsx_runtime_1 = require("react/jsx-runtime");
var createContextHelper_1 = require("./createContextHelper");
Object.defineProperty(exports, "createContextHelper", { enumerable: true, get: function () { return createContextHelper_1.createContextHelper; } });
var simpleWrapper_1 = require("./simpleWrapper");
Object.defineProperty(exports, "createHelper", { enumerable: true, get: function () { return simpleWrapper_1.createHelper; } });
var compositeWrapper_1 = require("./compositeWrapper");
Object.defineProperty(exports, "createHelpers", { enumerable: true, get: function () { return compositeWrapper_1.createHelpers; } });
/**
 * Composes the given helper instances together to create a React component
 * that you can wrap around other components.
 *
 * @param {...SimpleHelperInstance} ...helpers A variable number of instantiated helpers.
 * @returns {ReactComponent} A React.js component to wrap around other components.
 */
var wrap = function () {
    var helpers = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        helpers[_i] = arguments[_i];
    }
    var wrapperToItsArgsMap = new Map();
    helpers.forEach(function (helper) {
        var helperType = helper.helperType, wrapper = helper.wrapper, args = helper.args;
        var wrapperAlreadyInMap = wrapperToItsArgsMap.has(wrapper);
        if (helperType === 'simple') {
            // It's a non-composite wrapper - make sure it's not a dupe, then just push it
            if (wrapperAlreadyInMap) {
                throw new Error("Duplicate helper detected: ".concat(wrapper.toString()));
            }
            wrapperToItsArgsMap.set(wrapper, args);
        }
        else if (helperType === 'composite') {
            // It's a composite wrapper, so...
            // ... add it to the list, with empty args, if it's not already there...
            if (!wrapperAlreadyInMap) {
                wrapperToItsArgsMap.set(wrapper, nEmptyArrays(wrapper.length));
            }
            // ... and then set the args from this instance into the right slot
            wrapperToItsArgsMap.get(wrapper)[helper.helperIndex] = args;
        }
        else {
            throw new Error("Unexpected value for helperType: \"".concat(helperType, "\".\n      This is a bug in souvlaki, please report it here: https://github.com/camjackson/souvlaki/issues/new"));
        }
    });
    // Apply all the collected args to all of the wrappers, both simple and composite,
    // creating an array of React components that can now be composed together.
    var wrapperComponents = Array.from(wrapperToItsArgsMap).map(function (_a) {
        var wrapper = _a[0], args = _a[1];
        return wrapper.apply(void 0, args);
    });
    return composeComponents(wrapperComponents);
};
exports.wrap = wrap;
/**
 * @param {ReactComponent} wrappers e.g.: `[WrapperA, WrapperB, WrapperC]`
 * @returns a React component that wraps its children in each wrapper
 * in the given order, e.g.:
 * ({ children }) => (
 *   <WrapperA>
 *     <WrapperB>
 *       <WrapperC>
 *         {children}
 *       </WrapperC>
 *     </WrapperB>
 *   </WrapperA>
 * )
 * Note: It mutates its argument, reversing its order
 */
var composeComponents = function (wrappers) {
    if (wrappers.length === 0) {
        return function (_a) {
            var children = _a.children;
            return (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: children });
        };
    }
    return function (_a) {
        var children = _a.children;
        return wrappers
            .reverse()
            .reduce(function (previousChildren, NextWrapper) { return ((0, jsx_runtime_1.jsx)(NextWrapper, { children: previousChildren })); }, children);
    };
};
/**
 * E.g. nEmptyArrays(3) -> [[], [], []]
 */
var nEmptyArrays = function (n) { return Array(n).fill([]); };
